# -*- coding: utf-8 -*-
from .base import BaseCache


class TwoLayerCache(BaseCache):
    """
    2018-06-14
    实验性质的两级缓存，从使用角度出发
    只支持以下方法
    - set
    - get
    - get_many
    - delete
    - delete_many
    - reset
    """

    def __init__(self, L1, L2):
        """
        初始化时必须先在外部先初始化完毕实例
        """
        super().__init__()
        self.L1 = L1
        self.L2 = L2

    def add(self, key, value, timeout=None):
        raise NotImplementedError('not supported')

    def clear(self):
        raise NotImplementedError('not supported')

    def dec(self, key, delta=1, timeout=None):
        raise NotImplementedError('not supported')

    def delete(self, key):
        r1 = self.L1.delete(key)
        r2 = self.L2.delete(key)
        return r1 and r2

    def delete_many(self, *keys):
        r1 = self.L1.delete_many(*keys)
        r2 = self.L2.delete_many(*keys)
        return [x[0] and x[1] for x in zip(r1, r2)]

    def get(self, key, **options):
        rv = self.L1.get(key, **options)
        if rv is not None:
            return rv

        rv = self.L2.get(key, **options)
        return rv

    def get_dict(self, *key):
        raise NotImplementedError('not supported')

    def get_many(self, *keys, **options):
        # 先从L1取数据
        results = self.L1.get_many(*keys, **options)

        miss_keys = []
        for i in range(len(keys)):
            # 一些数据可能没有命中，整理出需要去L2获取的key列表
            if results[i] is None:
                miss_keys.append((i, keys[i]))

        if len(miss_keys) <= 0:
            # 全部命中，直接返回
            return results

        L2_keys = [x[1] for x in miss_keys]
        L2_results = self.L2.get_many(*L2_keys, **options)
        for j in range(len(L2_keys)):
            # 找到在原来结果中的位置，将内容填充进去
            idx, _ = miss_keys[j]
            results[idx] = L2_results[j]

        return results

    def has(self, key):
        raise NotImplementedError('not supported')

    def inc(self, key, delta=1, timeout=None):
        raise NotImplementedError('not supported')

    def set(self, key, value, timeout=None, **options):
        r1 = self.L1.set(key, value, timeout=timeout, **options)
        r2 = self.L2.set(key, value, timeout=timeout, **options)
        return r1 and r2

    def set_many(self, mapping, timeout=None, **options):
        """
        由于memcached没实现，所以这个方法暂时不可用
        """
        raise NotImplementedError('not supported')

    def exists(self, key):
        rv = self.L1.exists(key) or self.L2.exists(key)
        return rv

    def reset(self):
        """
        disconnect all connections
        """
        self.L1.reset()
        self.L2.reset()

    def beacon_before(self, name, func):
        self.L1.beacon_before(name, func)
        self.L2.beacon_before(name, func)

    def beacon_after(self, name, func):
        self.L1.beacon_after(name, func)
        self.L2.beacon_after(name, func)

    def setup_hook(self):
        self.L1.setup_hook()
        self.L2.setup_hook()

    def teardown_hook(self):
        self.L1.teardown_hook()
        self.L2.teardown_hook()
