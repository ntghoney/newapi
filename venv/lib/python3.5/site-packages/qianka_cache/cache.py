# -*- coding: utf-8 -*-
from functools import wraps
import logging
from threading import Lock
import types

import msgpack

from .marshal import plain
from .memcached_cache import MemcachedCache
from .memory_cache import MemoryCache
from .twolayer_cache import TwoLayerCache
from .null import NullCache
from .redis_cache import RedisCache
from .utils._collections import ScopedRegistry, ThreadLocalRegistry


logger = logging.getLogger(__name__)


class QKCache(object):
    """
    Usage:
    ```
    from application import cache
    cache.configure()
    value = cache.get('name')
    cache('namespace').set('key', value)
    ```
    """

    BACKENDS = (
        'redis', 'redisv2', 'memcached',
        'null', '2layer', 'memory',
    )

    def __init__(self):
        self._config = {}
        self._config.setdefault('CACHE_ENABLED', False)
        self._config.setdefault('CACHE_KEY_PREFIX', 'qianka')
        self._config.setdefault('CACHE_DEFAULT_TIMEOUT', 300)
        self._config.setdefault('CACHE_NODES',
                                {'default': ['redis://127.0.0.1']})
        # 上报数据采样率 N / 1
        # NOTE: 作为传进 statsd 方法的 rate 参数
        # 这个值应当是在 0 ~ 1 之间的浮点数
        self._config.setdefault('CACHE_METRIC_SAMPLE_RATE', 0)

        self._instances = {}
        self._instances_lock = Lock()

        # statsd.StatsClient
        self._stats = None

        # 是否希望上报性能数据
        self._want_metric_reported = False

        self._hook_targets = set([
            'add',
            'exists',
            'set',
            'get',
            'delete',
            'set_many',
            'get_many',
            'delete_many',
            'inc',
            'dec',
            'clear',
        ])

    def get_instances(self):
        return self._instances

    @property
    def config(self):
        return self._config

    def configure(self, config=None, **kwargs):
        """
        - CACHE_ENABLED
        - CACHE_NODES
        - CACHE_KEY_PREFIX
        - CACHE_DEFAULT_TIMEOUT     in seconds

        !!default is a must!! NODES could be:

        {
          'default': ('redis', ['redis://127.0.0.1', 'redis://127.0.0.1:6380']),

          # with weight
          'another': ('redis': [('redis://192.168.1.100/1', 2), ('redis://192.168.1.200/0', 5)]),
        }
        """
        if config:
            self._config.update(config)
        if kwargs:
            self._config.update(kwargs)

    def get_cache(self, name='default'):
        """
        根据配置名字获取缓存实例
        """
        with self._instances_lock:

            instances = self.get_instances()

            if name in instances:
                return instances[name]

            cache_enabled = self._config['CACHE_ENABLED']
            if not cache_enabled:
                logger.debug('disabled, init null cache')
                instances[name] = NullCache()
                return instances[name]

            cfg = self._config['CACHE_NODES'][name]
            rv = self._get_cache(cfg)
            instances[name] = rv

            if not self._want_metric_reported:
                return rv

            # 在调用 setup_metric_reporting 方法时,缓存实例可能尚未初始化
            # 那么上报性能钩子就没有设置，所以在获取缓存实例的同时
            # 若希望上报性能，则直接添加钩子
            self._setup_single_metric_reporting(name, rv)

            return rv

    def _get_cache(self, config):
        """
        根据配置内容获取缓存实例
        """
        if type(config) in (list, tuple):
            backend = config[0]
            nodes = config[1]
        else:
            backend = config
            nodes = []

        marshal = None
        if ':' in backend:
            backend, marshal = backend.split(':', maxsplit=1)

        QKCache._check_backend(backend)

        key_prefix = self._config['CACHE_KEY_PREFIX']
        timeout = self._config['CACHE_DEFAULT_TIMEOUT']

        if backend == 'redis':
            inst = self._init_redis_cache(
                nodes, marshal, key_prefix, timeout, True)
        elif backend == 'redisv2':
            inst = self._init_redis_cache(
                nodes, marshal, key_prefix, timeout, False)
        elif backend == 'memcached':
            inst = self._init_memcached_cache(
                nodes, marshal, key_prefix, timeout)
        elif backend == '2layer':
            inst = self._init_2layer_cache(nodes)
        elif backend == 'memory':
            # nodes 变量代表 size
            inst = self._init_memory_cache(nodes, timeout)
        else:
            logger.debug('init null cache')
            inst = NullCache()

        return inst

    def reset(self):
        """
        close all instances
        """
        with self._instances_lock:
            self.teardown_metric_reporting()
            instances = self.get_instances()
            for instance in instances.values():
                instance.reset()
            instances.clear()

    @staticmethod
    def _check_backend(backend):
        """preform various checking
        """
        if backend.lower() not in QKCache.BACKENDS:
            raise NotImplementedError(
                'unsupported cache backend: %s' % backend)

    #
    # sugar
    #

    def __call__(self, name='default'):
        return self.get_cache(name)

    def __getattr__(self, name):
        """
        magic ruby ``method_missing'' equivalent
        """
        if name not in (
            'add',
            'exists',
            'set',
            'get',
            'delete',
            'set_many',
            'get_many',
            'delete_many',
            'inc',
            'dec',
            'clear',
        ):
            raise RuntimeError('unknown cache action: %s'\
                               'please consult the cache API' % name)

        # delegate to default cache instance
        return getattr(self.get_cache(), name)

    def _init_redis_cache(
            self, nodes, marshal, key_prefix, timeout, hashring_use_name):
        """
        初始化RedisCache

        hashring_use_name
        True 表示使用名字作为hashring运算 适用backend:redis
        False 表示使用序号 适用backend:redisv2
        """
        if not marshal:
            marshal = msgpack
        elif marshal == 'plain':
            marshal = plain
        else:
            raise NotImplementedError(
                'unsupported marshal: %s' % marshal)

        logger.debug('init redis cache with nodes: %s' % nodes)
        rv = RedisCache(
            nodes,
            key_prefix=key_prefix,
            default_timeout=timeout,
            marshal_module=marshal,
            hashring_use_name=hashring_use_name,
        )
        return rv

    def _init_memcached_cache(self, nodes, marshal, key_prefix, timeout):
        if not marshal:
            marshal = msgpack
        elif marshal == 'plain':
            marshal = plain
        else:
            raise NotImplementedError(
                'unsupported marshal: %s' % marshal)

        logger.debug(
            'init memcached cache with nodes: %s' % nodes)
        rv = MemcachedCache(
            nodes,
            key_prefix=key_prefix,
            default_timeout=timeout,
            marshal_module=marshal)
        return rv

    def _init_2layer_cache(self, nodes):
        """
        初始化两级缓存，nodes的格式为
        {
          'L1': NODE_DEFINITION,
          'L2': NODE_DEFINITION,
        }
        此处的节点定义与普通的缓存定义一样，即允许 **多级之间是异构**
        只需要支持标准的 BaseCache 里的以下方法即可
        - set
        - set_many
        - get
        - get_many
        - delete
        - delete_many
        - reset
        """
        logger.debug('init 2layer cache with nodes: %s' % nodes)
        L1_config = nodes['L1']
        L1 = self._get_cache(L1_config)
        L2_config = nodes['L2']
        L2 = self._get_cache(L2_config)
        rv = TwoLayerCache(L1, L2)
        return rv

    def _init_memory_cache(self, size, timeout):
        rv = MemoryCache(size, timeout)
        return rv

    def report_metric(self, bind, rate):
        """
        返回一个“上报运行状态”的方法
        """
        def stat(func_name, options):
            if rate <= 0:
                return
            tc = options['timecost']
            metric = 'ops.cache.{}.{}.timecost'.format(bind, func_name)
            # logger.debug(metric)
            self._stats.timing(metric, tc * 1e3, rate=rate)
        return stat

    def setup_metric_reporting(self):
        """
        开启状态回报
        """
        self._want_metric_reported = True
        if self._stats is None:
            return
        for bind in [x for x in self._instances.keys()]:
            logger.debug('setup metric reporting for {}'.format(bind))
            inst = self._instances.get(bind)
            if inst is None:
                continue
            self._setup_single_metric_reporting(bind, inst)

    def _setup_single_metric_reporting(self, bind, inst):
        """
        给单个缓存实例设置性能上报
        """
        rate = self._config['CACHE_METRIC_SAMPLE_RATE']
        func = self.report_metric(bind, rate)
        for target in self._hook_targets:
            inst.beacon_after(target, func)
        inst.setup_hook()

    def teardown_metric_reporting(self):
        """
        关闭状态回报
        """
        self._want_metric_reported = False
        for bind in [x for x in self._instances.keys()]:
            logger.debug('teardown metric reporting for {}'.format(bind))
            inst = self._instances.get(bind)
            if inst is None:
                continue
            inst.teardown_hook()

    def cacheable(self, key, timeout=None, bind='default', condition=None):
        """
        对函数进行包装的缓存装饰器，默认行为如下

        - 以 key 为缓存键名
        - 无条件对结果进行缓存

        参数说明

        :key: (function|str) 缓存键名
              如果是函数，则会在调用包装内方法前先调用 key 函数
              接到的参数与包装内一致，用于决定动态的缓存键名
        :timeout: int 过期时间，单位秒，这个和缓存原来的 timeout 参数一致
                  默认的 None 代表使用配置的默认过期时间
        :bind: str 缓存配置名字，相当于 caehe(bind) 用法
        :condition: function 调用包装内方法后，根据情况进行缓存设置
                    接受的参数是 **包装内方法的返回值**
                    当 condition 传递函数时，
                    **只有该函数返回 True 时才设置缓存**
        """

        if not isinstance(key, str) and not callable(key):
            raise ValueError('key参数只允许str或者函数')

        if condition and not callable(condition):
            raise ValueError('condition必须是函数')

        def w(fn):

            # 嵌套情况复杂，如果包装的是静态方法
            # 将无法判断调用时的第一个参数是否为
            # 对象实例本身，造成参数错误
            if isinstance(fn, staticmethod):
                raise ValueError('@cacheable需在@staticmethod下面')

            if not isinstance(fn, types.FunctionType):
                raise ValueError('包装对象必须是函数')

            @wraps(fn)
            def cacheWrapper(*args, **kwargs):

                _cache = self.get_cache(bind)

                k = key
                if callable(key):
                    k = key(*args, **kwargs)

                rv = _cache.get(k)
                if rv is not None:
                    return rv

                rv = fn(*args, **kwargs)

                # 默认需要设置缓存
                do_set = True
                if condition and callable(condition):
                    do_set = False
                    if condition(rv):
                        do_set = True

                if do_set:
                    _cache.set(k, rv, timeout=timeout)

                return rv
            return cacheWrapper

        return w


def scoped_cache(cache, scopefunc=None):
    if scopefunc:
        cache.registry = ScopedRegistry(lambda: {}, scopefunc)
    else:
        cache.registry = ThreadLocalRegistry(lambda: {})

    cache.get_instances = lambda: cache.registry()
