# -*- coding: utf-8 -*-
from collections import defaultdict
from functools import wraps
import logging
import time


logger = logging.getLogger(__name__)


class BaseCache(object):
    """
    缓存API，从以下地址抄袭过来的
    http://werkzeug.pocoo.org/docs/0.14/contrib/cache/#cache-system-api
    """

    def __init__(self):
        self._before_hooks = defaultdict(list)
        self._after_hooks = defaultdict(list)
        self._hooked = []
        self._origin_funcs = {}
        self._has_hooked = False

    def add(self, key, value, timeout=None):
        pass

    def clear(self):
        pass

    def dec(self, key, delta=1, timeout=None):
        pass

    def delete(self, key):
        pass

    def delete_many(self, *keys):
        pass

    def get(self, key, **options):
        pass

    def get_dict(self, *key, **options):
        raise NotImplementedError()

    def get_many(self, *keys, **options):
        pass

    def has(self, key):
        raise NotImplementedError()

    def inc(self, key, delta=1, timeout=None):
        pass

    def set(self, key, value, timeout=None, **options):
        pass

    def set_many(self, mapping, timeout=None, **options):
        pass

    def exists(self, key):
        """
        alias for ``has''
        """
        return self.has(key)

    def reset(self):
        """
        disconnect all connections
        """
        pass

    # === 以下都是为了做钩子而准备的设施方法 ===

    def beacon_before(self, name, func):
        """
        注册一个新的钩子
        """
        if not hasattr(self, name):
            raise RuntimeError('not func named: %s' % name)
        inter = getattr(self, name)
        if not callable(inter):
            raise RuntimeError('%s is not a function' % name)
        if not callable(func):
            raise RuntimeError('func is not a function')
        self._before_hooks[name].append(func)

    def beacon_after(self, name, func):
        """
        注册一个新的钩子
        """
        if not hasattr(self, name):
            raise RuntimeError('not func named: %s' % name)
        inter = getattr(self, name)
        if not callable(inter):
            raise RuntimeError('%s is not a function' % name)
        if not callable(func):
            raise RuntimeError('func is not a function')
        self._after_hooks[name].append(func)

    def setup_hook(self):
        """
        配置钩子
        """
        if self._has_hooked:
            return

        hooked = set(
            [x for x in self._before_hooks.keys()] +
            [x for x in self._after_hooks.keys()]
        )

        # logger.debug('need to setup hook for {}'.format(hooked))

        # 遍历所有已经注册的钩子
        for name in hooked:
            # logger.debug('setup hook for {}'.format(name))
            # 获取原来的函数
            origin = getattr(self, name)
            # 并保存起来，用于恢复
            self._origin_funcs[name] = origin
            # 新创建一个函数
            new_func = self.make_wrapper(name, origin)
            # 用新函数替换原有函数
            setattr(self, name, new_func)

        self._hooked = hooked
        self._has_hooked = True

    def make_wrapper(self, name, origin):
        """
        造一个新的包装方法出来
        """
        @wraps(origin)
        def new_func(*args, **kwargs):
            # logger.debug('new_func: %s' % name)
            # logger.debug('args: %s' % str(args))
            # logger.debug('kwargs: %s' % str(kwargs))

            # 传递给钩子的参数内容
            options = {
                'args': args,
                'kwargs': kwargs,
            }

            # 钩子的函数调用开销较大，若没有钩子也调用一次函数
            # 会多出原来的至少一倍的时间开销，直接在这里判断
            # after_hooks 下同
            if name in self._before_hooks:
                # 执行前置钩子
                self._before_hook(name, options)

            _ts = time.time()
            rv = origin(*args, **kwargs)
            _te = time.time()
            timecost = _te - _ts
            options['rv'] = rv
            options['timecost'] = timecost

            # 执行后置钩子
            if name in self._after_hooks:
                self._after_hook(name, options)
            return rv
        new_func.__name__ = '(wrapper).{}'.format(name)
        return new_func

    def teardown_hook(self):
        """
        移除钩子，恢复原状
        """
        if not self._has_hooked:
            return
        for name in self._hooked:
            origin = self._origin_funcs[name]
            setattr(self, name, origin)
        self._hooked = []
        self._has_hooked = False

    def _before_hook(self, name, options):
        funcs = self._before_hooks.get(name) or []
        for func in funcs:
            func(name, options)

    def _after_hook(self, name, options):
        funcs = self._after_hooks.get(name) or []
        for func in funcs:
            func(name, options)
