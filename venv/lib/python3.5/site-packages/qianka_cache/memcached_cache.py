# -*- coding: utf-8 -*-
import logging

import pylibmc

from .base import BaseCache


logger = logging.getLogger(__name__)


class MemcachedCache(BaseCache):
    """
    """

    def __init__(self, hosts, marshal_module,
                 key_prefix='', default_timeout=300):
        """
        端口可选

        marshal_module 表示整理编码的模块，应支持标准的 Python marshal
        方法

          :loads:
          :dumps:

        主机例子

          [
            '127.0.0.1',
            '127.0.0.1:11211',
            '192.168.1.1:11212',
          ]
        """
        super().__init__()
        self.key_prefix = key_prefix
        self.default_timeout = default_timeout
        self.marshal_module = marshal_module

        self.client = pylibmc.Client(
            hosts, binary=False, behaviors={
                'tcp_nodelay': True,
            })

    def reset(self):
        self.client.disconnect_all()

    def _get_expiration(self, timeout):
        if timeout is None:
            timeout = self.default_timeout
        return timeout

    def _get_key(self, k):
        return self.key_prefix + k

    def dump_object(self, value):
        """
        将值内容变换成存进缓存服务器的二进制内容
        """
        rv = self.marshal_module.dumps(value, encoding='utf-8')
        return rv

    def load_object(self, b):
        """
        将缓存中取出的二进制内容反向加载出来
        """
        # logger.debug(b)
        if b is None:
            return None
        if not isinstance(b, bytes):
            # 取出的并非二进制内容，客户端原生的序列化，直接返回
            return b
        rv = self.marshal_module.loads(b, encoding='utf-8')
        return rv

    def exists(self, key):
        rv = self.client.exists(key)
        return rv

    def get(self, key, raw=False):
        k = self._get_key(key)
        b = self.client.get(k)
        if raw:
            return b

        rv = self.load_object(b)
        return rv

    def set(self, key, value, timeout=None, raw=False):
        timeout = self._get_expiration(timeout)
        dump = value
        k = self._get_key(key)
        if not raw:
            dump = self.dump_object(value)

        rv = self.client.set(k, dump, timeout)
        return rv

    def add(self, key, value, timeout=None, raw=False):
        timeout = self._get_expiration(timeout)
        dump = value
        k = self._get_key(key)
        if not raw:
            dump = self.dump_object(value)

        rv = self.client.add(k, dump, timeout)
        return rv

    def delete(self, key):
        k = self._get_key(key)
        rv = self.client.delete(k)
        return rv

    def get_many(self, *keys, **kwargs):
        raw = kwargs.pop('raw', False)
        _ = self.client.get_multi(keys)
        # 返回的是一个dict
        values = [_.get(x) for x in keys]
        if raw:
            return values
        rv = []
        for b in values:
            rv.append(self.load_object(b))
        return rv

    def set_many(self, mapping, timeout=None, raw=False):
        raise NotImplementedError()

    def delete_many(self, *keys):
        return self.client.delete_multi(keys)

    def inc(self, key, delta=1, timeout=None):
        raise NotImplementedError()

    def dec(self, key, delta=1, timeout=None):
        raise NotImplementedError()
