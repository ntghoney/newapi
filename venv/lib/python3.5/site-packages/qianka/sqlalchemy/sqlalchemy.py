# -*- coding: utf-8 -*-
from threading import Lock
from urllib.parse import urlencode

from sqlalchemy.engine import create_engine
from sqlalchemy.pool import NullPool
from sqlalchemy.sql import visitors
from sqlalchemy.sql import operators
from sqlalchemy.sql.schema import MetaData
from sqlalchemy.ext.automap import automap_base
from sqlalchemy.ext.horizontal_shard import ShardedSession
from sqlalchemy.orm.session import Session
from sqlalchemy.orm.session import sessionmaker
from sqlalchemy.orm.scoping import scoped_session


__all__ = ['QKSQLAlchemy', 'QKSession', 'QKShardSession']

_DEFAULT_SHARD_ID = ''


class _scoped_session(scoped_session):
    """
    支持 db.session(bind_key) 方式获取指定连接的 session，以兼容旧的代码。
    建议显视使用 db.get_session(bind_key) 来获取指定的 session
    """
    def __call__(self, *args, **kwargs):
        if args:
            # 只取第一个位置参数作为 bind_key，其他参数忽略
            return getattr(self.registry(), 'db').get_session(args[0])
        return super(_scoped_session, self).__call__(**kwargs)


class QKSession(Session):
    def __init__(self, db, **kwargs):
        super(QKSession, self).__init__(**kwargs)
        self.db = db


class QKShardSession(ShardedSession):
    def __init__(self, db, **kwargs):
        super(QKShardSession, self).__init__(
            shard_chooser=db.shard_chooser,
            id_chooser=db.id_chooser,
            query_chooser=db.query_chooser,
            shards=None,
            **kwargs
        )
        self.db = db

    def get_bind(self, mapper, shard_id=None,
                 instance=None, clause=None, **kw):
        """
        返回需要的数据库分片连接。
          - 如果指定了 shard_id，直接返回
          - 否则通过 shard_chooser() 计算需要的连接
        """
        if shard_id is None:
            shard_id = self.shard_chooser(mapper, instance, clause=clause)

        if shard_id is _DEFAULT_SHARD_ID:
            # 如果 shard_chooser 返回 _DEFAULT_SHARD_ID，依然使用缺省的数据库连接
            return self.db.get_engine()
        else:
            return self.db.get_engine(shard_id)

    def bind_shard(self, shard_id, bind):
        pass


class QKSQLAlchemy(object):
    """
    ```
    db = QKSQLAlchemy()
    db.configure({...})
    User = db.reflect_model('user')
    users = db.session.query(User).filter(User.id<10, User.status==0).all()
    for user in users:
        print(user.id, user.display_name)
    ```

    ----

    获取 session 的方法：
      - db.session 返回缺省 session
      - db.get_session(bind_key) 返回指定 session
      - db.session(bind_key) 同 db.get_session(...)

    获取 engine 的方法：
      - db.engine
      - dg.get_engine(bind_key)

    bind_key 不应为空字符串

    ----

    数据库横向拆分
    ```
    db.configure({
        'SQLALCHEMY_ENABLE_SHARD': True,
        'SQLALCHEMY_BINDS': {
            'shard_001': '...',
            'shard_002': '...',
            'shard_003': '...'
        }
    })
    db.shard_chooser = ...
    db.id_chooser = ...
    db.query_chooser = ...

    db.session.(...)
    ```

    通过改变 shard_chooser, id_chooser, query_chooser 方法，自定义数据库拆分实现
    缺省的（db.session）才支持 shard，命名的 session 不执行 chooser 方法
    """
    def __init__(self):
        self._config = {}
        self._config.setdefault('SQLALCHEMY_BINDS', None)
        self._config.setdefault('SQLALCHEMY_ENABLE_SHARD', False)
        self._config.setdefault('SQLALCHEMY_ENABLE_POOL', False)
        self._config.setdefault('SQLALCHEMY_POOL_SIZE', 1)
        self._config.setdefault('SQLALCHEMY_POOL_TIMEOUT', 30)
        self._config.setdefault('SQLALCHEMY_POOL_RECYCLE', 60)
        self._config.setdefault('SQLALCHEMY_MAX_OVERFLOW', 10)
        self._config.setdefault('SQLALCHEMY_ECHO', True)

        # 数据库链接引擎是多个请求间的 Session 共享的
        self._engines = {}
        self._engine_lock = Lock()

        self._sessions = {}
        self._session_lock = Lock()

        # auto mapped models
        self._tables = {}
        self._models = {}
        self._reflect_lock = Lock()

        # scopefunc
        self.scopefunc = None

        # shard
        self.shard_chooser = _shard_chooser
        self.id_chooser = _id_chooser
        self.query_chooser = _query_chooser

        class MagicSessionCaller(object):
            """
            2018-09-11 workaround

            背景： pylint 检查错误
            E1102 db.session is not callable (not-callable)

            因为原来 session 设计为 @property
            pylint 检查 @property 统一报这个错
            参考来源： https://bitbucket.org/logilab/pylint/pull-requests/120/emit-not-callable-when-calling-properties/diff

            先将 session 属性(attribute) 设置为一个变量，然后在这个
            基础上再做文章

            """
            def __init__(self, inst):
                self.inst = inst

            def __call__(self, bind_key=None):
                """
                对应 db.session('bind') 用法，
                当作方法调用时，相当于调用 get_session 方法
                """
                rv = self.inst.get_session(bind_key=bind_key)
                return rv

            def __getattr__(self, attr):
                """
                对应 db.session.execute 用法，
                将 .execute 调用代理到 session 对应的对象身上
                """
                rv = getattr(self.inst.get_session(bind_key=None), attr)
                return rv

        self.session = MagicSessionCaller(self)

        class MagicEngineCaller(object):
            """
            道理与session一样
            """
            def __init__(self, inst):
                self.inst = inst

            def __call__(self, bind_key=None):
                """
                对应 db.engine('bind') 用法，
                当作方法调用时，相当于调用 get_session 方法
                """
                rv = self.inst.get_engine(bind_key=bind_key)
                return rv

            def __getattr__(self, attr):
                """
                对应 db.engine.execute 用法，
                将 .execute 调用代理到 session 对应的对象身上
                """
                rv = getattr(self.inst.get_engine(bind_key=None), attr)
                return rv

        self.engine = MagicEngineCaller(self)

    @property
    def config(self):
        return self._config

    def configure(self, config=None, **kwargs):
        """
        - SQLALCHEMY_BINDS: {bind_key: uri}
        - SQLALCHEMY_ENABLE_SHARD: False
        - SQLALCHEMY_ENABLE_POOL: False
        - SQLALCHEMY_POOL_SIZE: 1
        - SQLALCHEMY_POOL_TIMEOUT: 30
        - SQLALCHEMY_POOL_RECYCLE: 60
        - SQLALCHEMY_MAX_OVERFLOW: 10
        - SQLALCHEMY_ECHO: True
        """
        if config:
            self._config.update(config)
        if kwargs:
            self._config.update(kwargs)

    def reset(self):
        for session in [x for x in self._sessions.values()]:
            session.remove()

    def hard_reset(self):
        for s in [x for x in self._sessions.keys()]:
            sess = self._sessions.pop(s)
            sess.rollback()
            sess.remove()
        self._sessions.clear()

        for e in [x for x in self._engines.keys()]:
            engine = self._engines.pop(e)
            engine.dispose()
        self._engines.clear()

    def commit_all(self):
        """
        提交所有已经打开的会话
        """
        for s in [x for x in self._sessions.keys()]:
            sess = self._sessions.get(s)
            sess.commit()

    def rollback_all(self):
        """
        回滚所有已经打开的会话
        """
        for s in [x for x in self._sessions.keys()]:
            sess = self._sessions.get(s)
            sess.rollback()

    def create_session(self, engine=None, shard=False):
        class_ = QKShardSession if shard else QKSession
        factory = sessionmaker(
            db=self, bind=engine, class_=class_,
            autocommit=False, autoflush=False
        )
        return _scoped_session(factory, scopefunc=self.scopefunc)

    def get_session(self, bind_key=None):
        """ 通过 bind_key 获取 db session
        """
        with self._session_lock:
            if bind_key in self._sessions:
                return self._sessions[bind_key]
            engine = self.get_engine(bind_key)
            if bind_key is None and self._config['SQLALCHEMY_ENABLE_SHARD']:
                session = self.create_session(engine, True)
            else:
                session = self.create_session(engine)
            self._sessions[bind_key] = session
            return session

    def create_engine(self, uri):
        options = {}
        if self._config['SQLALCHEMY_ENABLE_POOL']:
            options.update({
                'pool_size': self._config['SQLALCHEMY_POOL_SIZE'],
                'pool_timeout': self._config['SQLALCHEMY_POOL_TIMEOUT'],
                'pool_recycle': self._config['SQLALCHEMY_POOL_RECYCLE'],
                'max_overflow': self._config['SQLALCHEMY_MAX_OVERFLOW']
            })
        else:
            options.update({'poolclass': NullPool})

        if self._config['SQLALCHEMY_ECHO']:
            options.update({'echo': True, 'echo_pool': True})
        return create_engine(uri, **options)

    def get_engine(self, bind_key=None):
        """ 通过 bind_key 获取 db engine
        """
        with self._engine_lock:
            if bind_key in self._engines:
                return self._engines[bind_key]
            elif bind_key is None:
                # 兼容老的配置方式
                config = self._config.get('SQLALCHEMY_DATABASE_URI')
                # 当SQLALCHEMY_DATABASE_URI没有时，使用SQLALCHEMY_BINDS['default']
                if config is None:
                    config = self._config['SQLALCHEMY_BINDS']['default']
            else:
                config = self._config['SQLALCHEMY_BINDS'][bind_key]
            # 兼容老的URI写法，以及字典类型配置
            uri = self.get_uri(config)
            if uri is None:
                return None
            engine = self.create_engine(uri)
            self._engines[bind_key] = engine
            return engine

    def get_uri(self, config):
        """
        根据数据库配置拼出连接字符串，可用的项目有

        - connector 连接库
        - adapter 数据库类型
        - host 主机地址
        - port 端口
        - user 用户名
        - pwd 密码
        - charset 字符集
        - db 数据库名称
        - options 其他配置项目，字典类型
        """
        if isinstance(config, str):
            return config

        # 默认值基于sqlite出发，再根据类型变更
        default_host = ''

        connector = config.get('connector')
        adapter = config.get('adapter', 'sqlite')

        if adapter in ('mysql', 'postgresql'):
            default_host = '127.0.0.1'

        host = config.get('host', default_host)
        port = str(config.get('port', ''))
        user = config.get('user', '')
        pwd = config.get('pwd')
        charset = config.get('charset', 'utf8')
        options = config.get('options', {})
        db = config.get('db')
        if db is None:
            raise ValueError('请指定连接的数据库名字')

        schema = adapter
        if connector:
            schema += '+' + connector
        auth = user
        if pwd:
            auth += ':' + pwd
        auth += '@'

        server = host
        if port:
            server += ':' + port

        options['charset'] = charset
        d = {
            'schema': schema,
            'auth': auth,
            'server': server,
            'db': db,
            'charset': charset,
            'options': urlencode(options),
        }

        rv = '%(schema)s://%(auth)s%(server)s/%(db)s?%(options)s'
        rv %= d
        return rv

    def reflect_model(self, table_name, bind_key=None):
        """ 反向生成 ORM 的 Model
        :param table_name:
        :param bind_key:
        :return: ORMClass
        """
        with self._reflect_lock:
            if table_name in self._models:
                return self._models[table_name]

            engine = self.get_engine(bind_key)
            meta = MetaData(bind=engine)
            meta.reflect(only=[table_name])

            table = meta.tables[table_name]
            self._tables[table_name] = table

            Base = automap_base(metadata=meta)
            Base.prepare()

            model = getattr(Base.classes, table_name)
            model.__table__.metadata = None
            self._models[table_name] = model

            return model

    def reflect_table(self, table_name, bind_key=None):
        with self._reflect_lock:
            if table_name in self._tables:
                return self._tables[table_name]

            engine = self.get_engine(bind_key)
            meta = MetaData(bind=engine)
            meta.reflect(only=[table_name])

            table = meta.tables[table_name]
            table.metadata = None
            self._tables[table_name] = table

            return table


#
# 横向拆分缺省实现
# 返回 _DEFAULT_SHARD_ID 表示使用缺省连接，兼容非分片的实现
#

def _shard_chooser(mapper, instance, clause=None):
    """ A callable which, passed a Mapper, a mapped
        instance, and possibly a SQL clause, returns a shard ID.  This id
        may be based off of the attributes present within the object, or on
        some round-robin scheme. If the scheme is based on a selection, it
        should set whatever state on the instance to mark it in the future as
        participating in that shard.
    """
    return _DEFAULT_SHARD_ID


def _id_chooser(query, ident):
    """ A callable, passed a query and a tuple of identity
        values, which should return a list of shard ids where the ID might
        reside.  The databases will be queried in the order of this listing.
    """
    return [_DEFAULT_SHARD_ID]


def _query_chooser(query):
    """ For a given Query, returns the list of shard_ids
      where the query should be issued.  Results from all shards returned
      will be combined together into a single listing.
    """
    return [_DEFAULT_SHARD_ID]

    shard_ids = []
    for column, operator, value in _get_query_comparisons(query):
        pass

    if len(shard_ids) == 0:
        return [_DEFAULT_SHARD_ID]
    else:
        return shard_ids


# http://docs.sqlalchemy.org/en/latest/_modules/examples/sharding/attribute_shard.html
def _get_query_comparisons(query):
    """Search an orm.Query object for binary expressions.

    Returns expressions which match a Column against one or more
    literal values as a list of tuples of the form
    (column, operator, values).   "values" is a single value
    or tuple of values depending on the operator.

    """
    binds = {}
    clauses = set()
    comparisons = []

    def visit_bindparam(bind):
        # visit a bind parameter.

        # check in _params for it first
        if bind.key in query._params:
            value = query._params[bind.key]
        elif bind.callable:
            # some ORM functions (lazy loading)
            # place the bind's value as a
            # callable for deferred evaluation.
            value = bind.callable()
        else:
            # just use .value
            value = bind.value

        binds[bind] = value

    def visit_column(column):
        clauses.add(column)

    def visit_binary(binary):
        # special handling for "col IN (params)"
        if binary.left in clauses and \
                binary.operator == operators.in_op and \
                hasattr(binary.right, 'clauses'):
            comparisons.append(
                (binary.left, binary.operator,
                    tuple(binds[bind] for bind in binary.right.clauses)
                )
            )
        elif binary.left in clauses and binary.right in binds:
            comparisons.append(
                (binary.left, binary.operator,binds[binary.right])
            )

        elif binary.left in binds and binary.right in clauses:
            comparisons.append(
                (binary.right, binary.operator,binds[binary.left])
            )

    # here we will traverse through the query's criterion, searching
    # for SQL constructs.  We will place simple column comparisons
    # into a list.
    if query._criterion is not None:
        visitors.traverse_depthfirst(query._criterion, {},
                    {'bindparam':visit_bindparam,
                        'binary':visit_binary,
                        'column':visit_column
                    }
        )
    return comparisons
